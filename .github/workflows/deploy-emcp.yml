name: Deploy Admin to EKS

on:
  push:
    branches: [ main, dev, staging ]
    paths:
      - 'charts/admin/**'
      - '.github/workflows/deploy-emcp.yml'
      - '.github/workflows/k8s/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: eu-central-1
  EKS_CLUSTER_NAME: emcp-eks-cluster

jobs:
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      namespace: ${{ steps.set-env.outputs.namespace }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, use the provided input
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # For push events, use the branch name
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              ENVIRONMENT="prod"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENVIRONMENT="staging"
            elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
              ENVIRONMENT="dev"
            else
              echo "Unsupported branch for deployment: ${{ github.ref }}"
              exit 1
            fi
          fi
          
          # Set environment and namespace
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=emcp-$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          echo "Selected environment: $ENVIRONMENT"
          echo "Using namespace: emcp-$ENVIRONMENT"

  deploy-admin:
    name: Deploy Admin to EKS
    runs-on: ubuntu-latest
    needs: set-environment
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'
          
      # Create namespace first
      - name: Create namespace
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          echo "Creating namespace $NAMESPACE if it doesn't exist..."
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          
      # Harbor login using the docker/login-action
      - name: Login to Harbor
        uses: docker/login-action@v3
        with:
          registry: harbor.enclaive.cloud
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}
          
      # Create the Harbor credentials secret in Kubernetes
      - name: Create Harbor credentials secret in Kubernetes
        run: |
          # Create the secret
          kubectl create secret docker-registry harbor-creds \
            --docker-server=harbor.enclaive.cloud \
            --docker-username=${{ secrets.HARBOR_USERNAME }} \
            --docker-password=${{ secrets.HARBOR_PASSWORD }} \
            --namespace=${{ needs.set-environment.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Set Admin image tag
        id: set-tag
        run: |
          ENV="${{ needs.set-environment.outputs.environment }}"
          
          # Use simple tag names instead of SHA hashes - FIXED!
          if [ "$ENV" == "prod" ]; then
            TAG="prod"
          elif [ "$ENV" == "staging" ]; then
            TAG="staging"
          elif [ "$ENV" == "dev" ]; then
            TAG="dev"
          fi
          
          echo "admin_tag=$TAG" >> $GITHUB_OUTPUT
          echo "ADMIN_TAG=$TAG" >> $GITHUB_ENV
          
          echo "Using image tag: $TAG"
      
      # Deploy Admin service directly in the workflow instead of using scripts
      - name: Deploy Admin Service
        run: |
          ENV="${{ needs.set-environment.outputs.environment }}"
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "Deploying Admin service to $NAMESPACE..."
          
          # Determine log level based on environment
          if [ "$ENV" == "prod" ]; then
            LOG_LEVEL="info"
            LOG_FORMAT="json"
          elif [ "$ENV" == "staging" ]; then
            LOG_LEVEL="info"
            LOG_FORMAT="json"
          else
            LOG_LEVEL="debug"
            LOG_FORMAT="pretty"
          fi
          
          # Deploy using Helm with proper tag
          helm upgrade --install admin ./charts/admin \
            --namespace $NAMESPACE \
            --create-namespace \
            --set namespace=$NAMESPACE \
            --set domain=admin.enclaive.cloud \
            --set environment=$ENV \
            --set image.tag="${ADMIN_TAG}" \
            --set image.pullPolicy=Always \
            --set imagePullSecrets[0].name=harbor-creds \
            --set logging.level=$LOG_LEVEL \
            --set logging.format=$LOG_FORMAT \
            --force \
            --debug \
            --timeout 10m \
            --wait
          
          echo "Admin service deployed with image tag: ${ADMIN_TAG}"
          
      # Verify deployment status
      - name: Verify Admin deployment
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "Verifying Admin deployment..."
          kubectl rollout status statefulset/admin -n $NAMESPACE --timeout=300s || true
          
      - name: Report Admin deployment status
        if: always()
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "=== Admin Deployment Status for ${{ needs.set-environment.outputs.environment }} ==="
          echo "Admin: $(kubectl get statefulset admin -n $NAMESPACE -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo 'Not found')"
          
          echo "=== Admin Pod Status ==="
          kubectl get pods -n $NAMESPACE -l app=admin
          
          echo "=== Admin Service Status ==="
          kubectl get service admin -n $NAMESPACE
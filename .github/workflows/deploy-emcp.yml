name: Deploy Admin to EKS

on:
  push:
    branches: [ main, dev, staging ]
    paths:
      - 'charts/admin/**'
      - '.github/workflows/deploy-emcp.yml'
      - '.github/workflows/k8s/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: eu-central-1
  EKS_CLUSTER_NAME: emcp-eks-cluster

jobs:
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      namespace: ${{ steps.set-env.outputs.namespace }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, use the provided input
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # For push events, use the branch name
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              ENVIRONMENT="prod"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENVIRONMENT="staging"
            elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
              ENVIRONMENT="dev"
            else
              echo "Unsupported branch for deployment: ${{ github.ref }}"
              exit 1
            fi
          fi
          
          # Set environment and namespace
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=emcp-$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          echo "Selected environment: $ENVIRONMENT"
          echo "Using namespace: emcp-$ENVIRONMENT"

  diagnostics:
    name: Run Diagnostics
    runs-on: ubuntu-latest
    needs: set-environment
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          
      - name: Harbor login
        uses: docker/login-action@v3
        with:
          registry: harbor.enclaive.cloud
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}
      
      - name: Create diagnostic script
        run: |
          cat > diagnostics.sh << 'EOF'
          #!/bin/bash
          # Diagnostic script for Harbor image pull issues

          # Set namespace
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"

          echo "========================================================"
          echo "DETAILED KUBERNETES DIAGNOSTICS FOR HARBOR PULL ISSUES"
          echo "========================================================"

          echo "1. CHECKING ALL PODS IN NAMESPACE $NAMESPACE"
          kubectl get pods -n $NAMESPACE
          echo ""

          echo "2. CHECKING ALL SECRETS IN NAMESPACE $NAMESPACE"
          kubectl get secrets -n $NAMESPACE | grep harbor
          echo ""

          echo "3. CHECKING HARBOR-CREDS SECRET DETAILS"
          kubectl describe secret harbor-creds -n $NAMESPACE
          echo ""

          # Check if harbor-emcp-pull-secret exists, which is used by backend
          if kubectl get secret harbor-emcp-pull-secret -n $NAMESPACE &>/dev/null; then
            echo "4. CHECKING HARBOR-EMCP-PULL-SECRET DETAILS"
            kubectl describe secret harbor-emcp-pull-secret -n $NAMESPACE
          else
            echo "4. HARBOR-EMCP-PULL-SECRET DOES NOT EXIST"
          fi
          echo ""

          echo "5. DETAILED EVENTS FROM NAMESPACE (SORTED BY TIME)"
          kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -n 30
          echo ""

          echo "6. DETAILED POD INFORMATION FOR ADMIN PODS"
          ADMIN_PODS=$(kubectl get pods -n $NAMESPACE -l app=admin -o name)
          for pod in $ADMIN_PODS; do
            echo "Details for pod $pod:"
            kubectl describe $pod -n $NAMESPACE
            echo "---"
          done

          echo "7. CHECKING FOR BACKEND PODS (WHICH WORK)"
          BACKEND_PODS=$(kubectl get pods -n $NAMESPACE -l app=backend -o name)
          if [ -n "$BACKEND_PODS" ]; then
            for pod in $BACKEND_PODS; do
              echo "Working backend pod found: $pod"
              echo "Image pull secrets configuration:"
              kubectl get $pod -n $NAMESPACE -o jsonpath='{.spec.imagePullSecrets}'
              echo ""
            done
          else
            echo "No backend pods found in namespace $NAMESPACE"
          fi
          echo ""

          echo "8. CHECKING FOR IMAGE PULL BACKOFFS"
          kubectl get pods -n $NAMESPACE | grep -i "ImagePull\|ErrImage"
          echo ""

          echo "9. TESTING HARBOR TAG AVAILABILITY"
          # Try to list the available tags in Harbor
          TOKEN=$(curl -s -k -u "$HARBOR_USERNAME:$HARBOR_PASSWORD" "https://harbor.enclaive.cloud/service/token?service=harbor-registry&scope=repository:emcp/admin:pull" | jq -r '.token')
          
          if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
            echo "Available tags for emcp/admin repository:"
            curl -s -k -H "Authorization: Bearer $TOKEN" "https://harbor.enclaive.cloud/v2/emcp/admin/tags/list" | jq
          else
            echo "Failed to obtain Harbor token or list tags"
          fi
          echo ""

          echo "10. COMPARING SECRETS FORMAT"
          # Extract and decode the docker config from both secrets if they exist
          if kubectl get secret harbor-creds -n $NAMESPACE &>/dev/null; then
            echo "harbor-creds docker config:"
            kubectl get secret harbor-creds -n $NAMESPACE -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d | jq .
            echo ""
          fi

          if kubectl get secret harbor-emcp-pull-secret -n $NAMESPACE &>/dev/null; then
            echo "harbor-emcp-pull-secret docker config:"
            kubectl get secret harbor-emcp-pull-secret -n $NAMESPACE -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d | jq .
            echo ""
          fi

          echo "11. CHECKING REPOSITORY WITH NEW CREDENTIALS"
          echo "Creating test secret with non-sha tag..."
          
          # Try to create a secret and test pod using shorter tag
          kubectl create secret docker-registry harbor-test-secret \
            --docker-server=harbor.enclaive.cloud \
            --docker-username="$HARBOR_USERNAME" \
            --docker-password="$HARBOR_PASSWORD" \
            --namespace=$NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
          
          cat <<TEST | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: admin-test-pod
            namespace: $NAMESPACE
            labels:
              app: admin-test
          spec:
            containers:
            - name: admin-test
              image: harbor.enclaive.cloud/emcp/admin:dev
              imagePullPolicy: Always
            imagePullSecrets:
            - name: harbor-test-secret
            restartPolicy: Never
          TEST
          
          echo "Waiting for test pod..."
          sleep 15
          kubectl get pod admin-test-pod -n $NAMESPACE
          kubectl describe pod admin-test-pod -n $NAMESPACE
          
          echo "========================================================"
          echo "DIAGNOSTICS COMPLETE"
          echo "========================================================"
          EOF
          
          chmod +x diagnostics.sh
      
      - name: Run diagnostics
        env:
          HARBOR_USERNAME: ${{ secrets.HARBOR_USERNAME }}
          HARBOR_PASSWORD: ${{ secrets.HARBOR_PASSWORD }}
        run: |
          ./diagnostics.sh
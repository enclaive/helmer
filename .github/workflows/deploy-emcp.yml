name: Deploy to EKS

on:
  push:
    branches: [ main, dev, staging ]
    paths:
      - 'charts/admin/**'
      - 'charts/frontend/**'
      - 'charts/backend/**'
      - '.github/workflows/deploy-emcp.yml'
      - 'k8s/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: eu-central-1
  EKS_CLUSTER_NAME: emcp-eks-cluster

jobs:
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      namespace: ${{ steps.set-env.outputs.namespace }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, use the provided input
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # For push events, use the branch name
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              ENVIRONMENT="prod"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENVIRONMENT="staging"
            elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
              ENVIRONMENT="dev"
            else
              echo "Unsupported branch for deployment: ${{ github.ref }}"
              exit 1
            fi
          fi
          
          # Set environment and namespace
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=emcp-$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          echo "Selected environment: $ENVIRONMENT"
          echo "Using namespace: emcp-$ENVIRONMENT"

  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: set-environment
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          # Add validation flag to bypass validation error temporarily
          kubectl create namespace ${{ needs.set-environment.outputs.namespace }} --dry-run=client -o yaml --validate=false | kubectl apply -f -
          
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'
          
      # Harbor login using the docker/login-action to align with the other workflow
      - name: Login to Harbor
        uses: docker/login-action@v3
        with:
          registry: harbor.enclaive.cloud
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}
          
      # Create the Harbor credentials secret in Kubernetes
      - name: Create Harbor credentials secret in Kubernetes
        run: |
          # Create the secret
          kubectl create secret docker-registry harbor-creds \
            --docker-server=harbor.enclaive.cloud \
            --docker-username=${{ secrets.HARBOR_USERNAME }} \
            --docker-password=${{ secrets.HARBOR_PASSWORD }} \
            --namespace=${{ needs.set-environment.outputs.namespace }} \
            --dry-run=client -o yaml --validate=false | kubectl apply -f -
      
      - name: Set image tags based on environment
        id: set-tags
        run: |
          ENV="${{ needs.set-environment.outputs.environment }}"
          
          if [ "$ENV" == "prod" ]; then
            ADMIN_TAG="prod-${{ github.sha }}"
            FRONTEND_TAG="prod-${{ github.sha }}"
            BACKEND_TAG="prod-${{ github.sha }}"
          elif [ "$ENV" == "staging" ]; then
            ADMIN_TAG="staging-${{ github.sha }}"
            FRONTEND_TAG="staging-${{ github.sha }}"
            BACKEND_TAG="staging-${{ github.sha }}"
          elif [ "$ENV" == "dev" ]; then
            ADMIN_TAG="dev-${{ github.sha }}"
            FRONTEND_TAG="dev-${{ github.sha }}"
            BACKEND_TAG="dev-${{ github.sha }}"
          fi
          
          echo "admin_tag=$ADMIN_TAG" >> $GITHUB_OUTPUT
          echo "frontend_tag=$FRONTEND_TAG" >> $GITHUB_OUTPUT
          echo "backend_tag=$BACKEND_TAG" >> $GITHUB_OUTPUT
          
          # Export tags as environment variables for the deployment scripts
          echo "ADMIN_TAG=$ADMIN_TAG" >> $GITHUB_ENV
          echo "FRONTEND_TAG=$FRONTEND_TAG" >> $GITHUB_ENV
          echo "BACKEND_TAG=$BACKEND_TAG" >> $GITHUB_ENV
        
      # Make the deployment scripts executable
      - name: Make deployment scripts executable
        run: |
          mkdir -p k8s
          cp .github/workflows/k8s/* k8s/
          chmod +x k8s/*.sh
          
      # Deploy Admin service
      - name: Deploy Admin Service
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          ENV="${{ needs.set-environment.outputs.environment }}"
          
          echo "Deploying Admin service..."
          helm upgrade --install admin ./charts/admin \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./charts/admin/environments/values.$ENV.yaml \
            --set image.tag="${ADMIN_TAG}" \
            --set imagePullSecrets[0].name=harbor-creds \
            --set environment=$ENV \
            --set namespace=$NAMESPACE \
            --timeout 10m \
            --wait
          
          echo "Admin service deployed"
          
      # Deploy Frontend service
      - name: Deploy Frontend Service
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          ENV="${{ needs.set-environment.outputs.environment }}"
          
          # Set domain and URL values based on environment
          if [ "$ENV" == "prod" ]; then
            API_URL="https://emcp-prod.enclaive.cloud"
            APP_URL="https://console.enclaive.cloud"
            BETA_FEATURES="false"
          elif [ "$ENV" == "staging" ]; then
            API_URL="https://emcp-staging.enclaive.cloud"
            APP_URL="https://staging.console.enclaive.cloud"
            BETA_FEATURES="true"
          elif [ "$ENV" == "dev" ]; then
            API_URL="https://emcp-dev.enclaive.cloud"
            APP_URL="https://dev.console.enclaive.cloud"
            BETA_FEATURES="true"
          fi
          
          echo "Deploying Frontend service..."
          helm upgrade --install frontend ./charts/frontend \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./charts/frontend/environments/$ENV.yaml \
            --set image.tag="${FRONTEND_TAG}" \
            --set imagePullSecrets[0].name=harbor-creds \
            --set environment=$ENV \
            --set api.url="$API_URL" \
            --set app.url="$APP_URL" \
            --set features.enableBetaFeatures=$BETA_FEATURES \
            --timeout 10m \
            --wait
          
          echo "Frontend service deployed"
          
      # Deploy Backend service
      - name: Deploy Backend Service
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          ENV="${{ needs.set-environment.outputs.environment }}"
          
          # Set logging level and features based on environment
          if [ "$ENV" == "prod" ]; then
            LOG_LEVEL="info"
            ENABLE_BACKUPS="true"
          elif [ "$ENV" == "staging" ]; then
            LOG_LEVEL="info"
            ENABLE_BACKUPS="true"
          elif [ "$ENV" == "dev" ]; then
            LOG_LEVEL="debug"
            ENABLE_BACKUPS="false"
          fi
          
          echo "Deploying Backend service..."
          helm upgrade --install backend ./charts/backend \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --values ./charts/backend/environments/$ENV.yaml \
            --set image.tag="${BACKEND_TAG}" \
            --set imagePullSecrets[0].name=harbor-creds \
            --set environment=$ENV \
            --set logging.level=$LOG_LEVEL \
            --set features.enableBackups=$ENABLE_BACKUPS \
            --timeout 15m \
            --wait \
            --debug
          
          echo "Backend service deployed"
          
      - name: Verify deployments
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "Verifying Admin deployment..."
          kubectl rollout status statefulset/admin -n $NAMESPACE --timeout=300s || true
          
          echo "Verifying Frontend deployment..."
          kubectl rollout status statefulset/frontend -n $NAMESPACE --timeout=300s || true
          
          echo "Verifying Backend deployment..."
          kubectl rollout status statefulset/backend -n $NAMESPACE --timeout=300s || true
          
      - name: Report deployment status
        if: always()
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "=== Deployment Status for ${{ needs.set-environment.outputs.environment }} ==="
          echo "Admin: $(kubectl get statefulset admin -n $NAMESPACE -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo 'Not found')"
          echo "Frontend: $(kubectl get statefulset frontend -n $NAMESPACE -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo 'Not found')"
          echo "Backend: $(kubectl get statefulset backend -n $NAMESPACE -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null || echo 'Not found')"
          
          echo "=== Pod Status ==="
          kubectl get pods -n $NAMESPACE -l app=admin
          kubectl get pods -n $NAMESPACE -l app=frontend
          kubectl get pods -n $NAMESPACE -l app=backend
          
          echo "=== Service Status ==="
          kubectl get services -n $NAMESPACE
name: Deploy Services to EKS from ECR

on:
  push:
    branches: [ main, dev, staging ]
    paths:
      - 'charts/admin/**'
      - 'charts/backend/**'
      - 'charts/frontend/**'
      - 'charts/redis/**'
      - '.github/workflows/deploy-emcp.yml'
      - '.github/workflows/k8s/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      deploy_admin:
        description: 'Deploy admin service'
        required: false
        default: true
        type: boolean
      deploy_backend:
        description: 'Deploy backend service'
        required: false
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy frontend service'
        required: false
        default: true
        type: boolean
      deploy_redis:
        description: 'Deploy redis service'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: eu-central-1
  EKS_CLUSTER_NAME: emcp-eks-cluster
  AWS_ACCOUNT_ID: 886093416603

jobs:
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      namespace: ${{ steps.set-env.outputs.namespace }}
    
    steps:
      - name: Set environment based on branch or input
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual runs, use the provided input
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            # For push events, use the branch name
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              ENVIRONMENT="prod"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENVIRONMENT="staging"
            elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
              ENVIRONMENT="dev"
            else
              echo "Unsupported branch for deployment: ${{ github.ref }}"
              exit 1
            fi
          fi
          
          # Set environment and namespace
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=emcp-$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          echo "Selected environment: $ENVIRONMENT"
          echo "Using namespace: emcp-$ENVIRONMENT"

  check-changes:
    name: Check for Changes
    runs-on: ubuntu-latest
    outputs:
      admin_changed: ${{ steps.check-folders.outputs.admin_changed }}
      backend_changed: ${{ steps.check-folders.outputs.backend_changed }}
      frontend_changed: ${{ steps.check-folders.outputs.frontend_changed }}
      redis_changed: ${{ steps.check-folders.outputs.redis_changed }}
      workflow_changed: ${{ steps.check-folders.outputs.workflow_changed }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Needed for file comparison with previous commit
      
      - name: Check which folders changed
        id: check-folders
        run: |
          # For workflow_dispatch, use the input values
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "admin_changed=${{ github.event.inputs.deploy_admin }}" >> $GITHUB_OUTPUT
            echo "backend_changed=${{ github.event.inputs.deploy_backend }}" >> $GITHUB_OUTPUT
            echo "frontend_changed=${{ github.event.inputs.deploy_frontend }}" >> $GITHUB_OUTPUT
            echo "redis_changed=${{ github.event.inputs.deploy_redis }}" >> $GITHUB_OUTPUT
            echo "workflow_changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For push events, check which files changed
          echo "Checking changes in the last commit..."
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD || git diff --name-only $(git rev-parse --short HEAD^) $(git rev-parse --short HEAD))
          echo "Changed files: $CHANGED_FILES"
          
          # Default all to false
          ADMIN_CHANGED="false"
          BACKEND_CHANGED="false"
          FRONTEND_CHANGED="false"
          REDIS_CHANGED="false"
          WORKFLOW_CHANGED="false"
          
          # Check if specific folders were modified
          if echo "$CHANGED_FILES" | grep -q "^charts/admin/"; then
            echo "Admin service files changed"
            ADMIN_CHANGED="true"
          else
            echo "No changes in admin service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^charts/backend/"; then
            echo "Backend service files changed"
            BACKEND_CHANGED="true"
          else
            echo "No changes in backend service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^charts/frontend/"; then
            echo "Frontend service files changed"
            FRONTEND_CHANGED="true"
          else
            echo "No changes in frontend service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^charts/redis/"; then
            echo "Redis service files changed"
            REDIS_CHANGED="true"
          else
            echo "No changes in redis service"
          fi
          
          # Check if workflow files changed
          if echo "$CHANGED_FILES" | grep -q "^.github/workflows/"; then
            echo "Workflow files changed"
            WORKFLOW_CHANGED="true"
          else
            echo "No changes in workflow files"
          fi
          
          # Set outputs explicitly
          echo "admin_changed=${ADMIN_CHANGED}" >> $GITHUB_OUTPUT
          echo "backend_changed=${BACKEND_CHANGED}" >> $GITHUB_OUTPUT
          echo "frontend_changed=${FRONTEND_CHANGED}" >> $GITHUB_OUTPUT
          echo "redis_changed=${REDIS_CHANGED}" >> $GITHUB_OUTPUT
          echo "workflow_changed=${WORKFLOW_CHANGED}" >> $GITHUB_OUTPUT
          
          # Debug outputs
          echo "admin_changed: ${ADMIN_CHANGED}"
          echo "backend_changed: ${BACKEND_CHANGED}"
          echo "frontend_changed: ${FRONTEND_CHANGED}"
          echo "redis_changed: ${REDIS_CHANGED}"
          echo "workflow_changed: ${WORKFLOW_CHANGED}"

  deploy-redis:
    name: Deploy Redis to EKS
    needs: [set-environment, check-changes]
    if: needs.check-changes.outputs.redis_changed == 'true' || needs.check-changes.outputs.workflow_changed == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'
          
      # Create namespace first (if it doesn't exist)
      - name: Create namespace
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          echo "Creating namespace $NAMESPACE if it doesn't exist..."
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      # Set Redis configuration based on environment
      - name: Set Redis configuration
        id: redis-config
        run: |
          ENV="${{ needs.set-environment.outputs.environment }}"
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          # Use consistent tag for Redis across environments
          TAG="6.2-alpine"
          echo "redis_tag=$TAG" >> $GITHUB_OUTPUT
          echo "REDIS_TAG=$TAG" >> $GITHUB_ENV
          
          # Set storage size based on environment
          if [ "$ENV" == "prod" ]; then
            echo "redis_storage_size=1Gi" >> $GITHUB_OUTPUT
            echo "REDIS_STORAGE_SIZE=1Gi" >> $GITHUB_ENV
          elif [ "$ENV" == "staging" ]; then
            echo "redis_storage_size=768Mi" >> $GITHUB_OUTPUT
            echo "REDIS_STORAGE_SIZE=768Mi" >> $GITHUB_ENV
          else
            echo "redis_storage_size=512Mi" >> $GITHUB_OUTPUT
            echo "REDIS_STORAGE_SIZE=512Mi" >> $GITHUB_ENV
          fi
          
          # All environments use the same storage class
          echo "redis_storage_class=openebs-hostpath" >> $GITHUB_OUTPUT
          echo "REDIS_STORAGE_CLASS=openebs-hostpath" >> $GITHUB_ENV
          
          echo "Using Redis image tag: $TAG"
          echo "Using Redis storage size: $REDIS_STORAGE_SIZE"
          echo "Using Redis storage class: $REDIS_STORAGE_CLASS"
      
      # Deploy Redis service
      - name: Deploy Redis Service
        run: |
          ENV="${{ needs.set-environment.outputs.environment }}"
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "Deploying Redis service to $NAMESPACE with tag $REDIS_TAG..."
          
          # Deploy using environment-specific values file
          if [ -f "./charts/redis/environments/values.${ENV}.yaml" ]; then
            echo "Using environment-specific values file: values.${ENV}.yaml"
            helm upgrade --install redis ./charts/redis \
              --namespace $NAMESPACE \
              --values ./charts/redis/environments/values.${ENV}.yaml \
              --set namespace=$NAMESPACE \
              --set image.repository=redis \
              --set image.tag=$REDIS_TAG \
              --set persistence.storageClass=$REDIS_STORAGE_CLASS \
              --set persistence.size=$REDIS_STORAGE_SIZE \
              --timeout 10m \
              --wait
          else
            echo "Environment-specific values file not found, using inline configuration"
            helm upgrade --install redis ./charts/redis \
              --namespace $NAMESPACE \
              --set namespace=$NAMESPACE \
              --set image.repository=redis \
              --set image.tag=$REDIS_TAG \
              --set image.pullPolicy=Always \
              --set service.type=ClusterIP \
              --set service.port=6379 \
              --set service.targetPort=6379 \
              --set redis.port=6379 \
              --set redis.config.maxmemory="128mb" \
              --set redis.config.maxmemory-policy="allkeys-lru" \
              --set redis.config.appendonly="yes" \
              --set redis.config.appendfsync="everysec" \
              --set persistence.enabled=true \
              --set persistence.storageClass=$REDIS_STORAGE_CLASS \
              --set persistence.size=$REDIS_STORAGE_SIZE \
              --set resources.limits.cpu=200m \
              --set resources.limits.memory=256Mi \
              --set resources.requests.cpu=100m \
              --set resources.requests.memory=128Mi \
              --timeout 10m \
              --wait
          fi
          
          echo "Redis service deployed in namespace $NAMESPACE"
          
      # Verify deployment status with improved checks
      - name: Verify Redis deployment
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "Verifying Redis deployment..."
          
          # Check if the StatefulSet exists
          if ! kubectl get statefulset redis -n $NAMESPACE > /dev/null 2>&1; then
            echo "Error: Redis StatefulSet not found"
            exit 1
          fi
          
          # Check if the pods are running using a more reliable method
          MAX_ATTEMPTS=12
          ATTEMPT=0
          SLEEP_TIME=10
          SUCCESS=false
          
          echo "Checking if Redis pods are ready..."
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Get desired and ready replicas
            DESIRED=$(kubectl get statefulset redis -n $NAMESPACE -o jsonpath='{.spec.replicas}')
            READY=$(kubectl get statefulset redis -n $NAMESPACE -o jsonpath='{.status.readyReplicas}')
            
            echo "Redis pods: $READY/$DESIRED ready (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            
            # Check if any pods exist
            if [ -z "$READY" ]; then
              READY=0
            fi
            
            # Check if pods are running and ready
            if [ "$READY" == "$DESIRED" ] && [ "$DESIRED" != "0" ]; then
              # Further verify Redis is actually functioning by running a Redis command
              if kubectl exec -n $NAMESPACE $(kubectl get pod -n $NAMESPACE -l app=redis -o jsonpath='{.items[0].metadata.name}') -- redis-cli ping | grep -q PONG; then
                echo "✅ Redis is running and responding to commands correctly!"
                SUCCESS=true
                break
              else
                echo "Redis pod is ready but not responding to commands yet. Waiting..."
              fi
            fi
            
            echo "Waiting for Redis to be ready... (${ATTEMPT}/${MAX_ATTEMPTS})"
            sleep $SLEEP_TIME
          done
          
          if [ "$SUCCESS" != "true" ]; then
            echo "Timed out waiting for Redis to be ready. Collecting diagnostic information..."
            kubectl describe statefulset redis -n $NAMESPACE
            kubectl get pods -n $NAMESPACE -l app=redis -o wide
            kubectl describe pods -n $NAMESPACE -l app=redis
            exit 1
          fi
      
      - name: Report Redis deployment status
        if: always()
        run: |
          NAMESPACE="${{ needs.set-environment.outputs.namespace }}"
          
          echo "=== Redis Deployment Status for ${{ needs.set-environment.outputs.environment }} ==="
          kubectl get statefulset redis -n $NAMESPACE
          
          echo "=== Redis Pod Status ==="
          kubectl get pods -n $NAMESPACE -l app=redis
          
          echo "=== Redis Service Status ==="
          kubectl get service redis -n $NAMESPACE
          
          echo "=== Redis PVC Status ==="
          kubectl get pvc -n $NAMESPACE -l app=redis